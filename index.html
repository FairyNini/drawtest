<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lottery Draw with Pointer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f7f7f7;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 600px;
      margin: auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      margin-top: 0;
    }

    /* The static wheel container */
    #wheel-container {
      position: relative;
      margin: 20px auto;
      width: 400px;
      height: 400px;
      border-radius: 50%;
      overflow: hidden;
      border: 5px solid #333;
    }

    /* The static wheel (conic gradient) */
    #wheel {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      position: relative; /* so we can absolutely position labels inside */
    }

    /* Prize labels inside each slice */
    .wheel-label {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: center;
      font-size: 14px;
      font-weight: bold;
      white-space: nowrap;
    }

    /* The spinning pointer (big black triangle) */
    #pointer {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) rotate(0deg);
      transform-origin: 50% 50%; /* spin around its own center */
      pointer-events: none;     /* don't block clicks */
    }
    /* Make the pointer a tall triangle, tip outward to the wheel edge */
    #pointer::before {
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      /* Adjust these borders to control pointer shape/length */
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 180px solid black; /* extends ~180px from center */
      transform: translate(-50%, -100%);
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }

    .message {
      margin-top: 10px;
      font-weight: bold;
      color: green;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Lottery Draw</h1>
  <button id="drawBtn">Draw Now</button>

  <div id="wheel-container">
    <!-- The static wheel (conic gradient) -->
    <div id="wheel"></div>
    <!-- The spinning pointer -->
    <div id="pointer"></div>
  </div>

  <div class="message" id="resultMsg"></div>
</div>

<script>
/****************************************************
 * 1) CONFIGURE PRIZES (NAME + PROBABILITY)
 *    The script adapts automatically if you
 *    change these values or add more prizes.
 ****************************************************/
const prizes = [
  { name: "1st Prize", probability: 10 },
  { name: "2nd Prize", probability: 30 },
  { name: "3rd Prize", probability: 60 }
];
// Compute total probability to handle any future changes
const totalProb = prizes.reduce((sum, p) => sum + p.probability, 0);

/****************************************************
 * 2) RENDER THE STATIC WHEEL WITH CORRECT SLICES
 *    The first slice (prizes[0]) starts at 12 o'clock (0Â°).
 *    Slices follow in order, clockwise.
 ****************************************************/
const wheel = document.getElementById("wheel");

function renderWheel() {
  wheel.innerHTML = ""; // Clear any old labels
  let startAngle = 0;
  let gradientParts = [];

  prizes.forEach(prize => {
    // Each slice angle
    const sliceAngle = (prize.probability / totalProb) * 360;
    const endAngle = startAngle + sliceAngle;

    // Get a non-black random color
    const sliceColor = getNonBlackColor();

    // Add to conic-gradient definition
    gradientParts.push(`${sliceColor} ${startAngle}deg ${endAngle}deg`);

    // Add a label at the midpoint of this slice
    const labelAngle = startAngle + sliceAngle / 2;
    const label = document.createElement("div");
    label.className = "wheel-label";
    // Show "Prize Name (XX%)"
    label.textContent = `${prize.name} (${prize.probability}%)`;

    // Position the label
    label.style.transform = `
      translate(-50%, -50%)
      rotate(${labelAngle}deg)
      translate(140px)
      rotate(-${labelAngle}deg)
    `;
    wheel.appendChild(label);

    startAngle = endAngle;
  });

  // Apply the conic gradient to the wheel
  wheel.style.background = `conic-gradient(${gradientParts.join(", ")})`;
}

/**
 * Return a random hex color that is NOT black (#000000).
 */
function getNonBlackColor() {
  let color;
  do {
    color = getRandomColor();
  } while (color.toLowerCase() === "#000000");
  return color;
}

/**
 * Return a random #RRGGBB color.
 */
function getRandomColor() {
  const letters = "0123456789ABCDEF";
  let color = "#";
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

renderWheel(); // Draw slices on load

/****************************************************
 * 3) SPIN THE POINTER (DECELERATION ANIMATION)
 *    We'll pick a random slice (weighted by probability),
 *    then compute that slice's midpoint angle, and
 *    spin the pointer to land on it.
 ****************************************************/
const pointer = document.getElementById("pointer");
let spinning = false;

/**
 * Weighted random selection: returns index of chosen prize
 */
function selectPrize() {
  let rand = Math.random() * totalProb;
  for (let i = 0; i < prizes.length; i++) {
    rand -= prizes[i].probability;
    if (rand <= 0) return i;
  }
  // Fallback (should not happen)
  return prizes.length - 1;
}

/**
 * Get midpoint angle of the slice at `prizeIndex`.
 */
function getPrizeMidAngle(prizeIndex) {
  let startAngle = 0;
  for (let i = 0; i < prizeIndex; i++) {
    startAngle += (prizes[i].probability / totalProb) * 360;
  }
  const sliceAngle = (prizes[prizeIndex].probability / totalProb) * 360;
  return startAngle + sliceAngle / 2;
}

/**
 * Spin the pointer to land on `finalAngle`.
 * Use a simple deceleration approach.
 */
function spinPointer(finalAngle, callback) {
  spinning = true;
  let currentAngle = 0;

  // Extra full rotations so user sees multiple spins
  const extraSpins = Math.floor(Math.random() * 3) + 3; // 3..5
  const targetAngle = extraSpins * 360 + finalAngle;

  // Animation variables
  let velocity = 45;       // degrees per frame
  const deceleration = 0.2; // slow down each frame

  function animate() {
    const remaining = targetAngle - currentAngle;
    if (remaining > 0) {
      if (remaining > velocity) {
        currentAngle += velocity;
        velocity -= deceleration;
        if (velocity < 0.5) velocity = 0.5; // clamp min speed
      } else {
        // if what's left is less than velocity, jump to final
        currentAngle = targetAngle;
      }
      pointer.style.transform = `translate(-50%, -50%) rotate(${currentAngle}deg)`;
      requestAnimationFrame(animate);
    } else {
      // done spinning
      spinning = false;
      callback();
    }
  }
  requestAnimationFrame(animate);
}

/****************************************************
 * 4) WHEN USER CLICKS "DRAW NOW", SPIN THE POINTER
 ****************************************************/
const drawBtn = document.getElementById("drawBtn");
const resultMsg = document.getElementById("resultMsg");

drawBtn.addEventListener("click", function() {
  if (spinning) return; // ignore if already spinning
  resultMsg.textContent = "";

  // 1) Weighted random to pick a prize
  const chosenIndex = selectPrize();
  const chosenPrize = prizes[chosenIndex];

  // 2) Midpoint angle for that slice
  const angle = getPrizeMidAngle(chosenIndex);

  // 3) Spin pointer to that angle
  spinPointer(angle, () => {
    // Show result after spin finishes
    resultMsg.textContent = `Congratulations! You won: ${chosenPrize.name}`;
  });
});
</script>
</body>
</html>
